<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>STT Test - Opus 48kHz</title>
  <style>
    body.recording { background-color: #fffae6; }
    #transcript { white-space: pre-wrap; border: 1px solid #ccc; padding: 10px; height: 150px; overflow-y: auto; }
    #status { margin-top: 10px; font-weight: bold; color: #444; }
  </style>
</head>
<body>
  <h1>ðŸŽ¤ STT Microphone Test (Opus 48kHz)</h1>
  <button id="start">Start</button>

  <div id="captions"></div>
  <div id="status"></div>

<script>
let ws;
let mediaRecorder;
let stream;
let reconnectTimeout = null;

const captions = window.document.getElementById('captions');
const statusDiv = window.document.getElementById('status');
const startBtn = window.document.getElementById('start');

  let microphone;
let socket;
let isRunning = false; // ×ž×¦×‘ ×”×× ×¤×•×¢×œ ××• ×œ×

startBtn.addEventListener("click", async () => {
  if (!isRunning) {
    // â–¶ï¸ ×”×ª×—×œ×”
    socket = new WebSocket(`wss://${window.location.host}`);

    socket.addEventListener("open", async () => {
      console.log("âœ… connected to server");
      try {
        microphone = await getMicrophone();
        await openMicrophone(microphone, socket);
        startBtn.textContent = "STOP"; // ×©×™× ×•×™ ×˜×§×¡×˜ ×‘×›×¤×ª×•×¨
        isRunning = true;
      } catch (error) {
        console.error("âš ï¸ error opening microphone:", error);
      }
    });

    socket.addEventListener("message", (event) => {
      if (event.data === "") return;
      let data;
      try {
        data = JSON.parse(event.data);
      } catch (e) {
        console.error("âš ï¸ Failed to parse JSON:", e);
        return;
      }
      if (data && data.channel && data.channel.alternatives[0].transcript !== "") {
        const span = document.createElement('div');
        span.textContent = data.channel.alternatives[0].transcript;
        captions.appendChild(span);
      }
    });

    socket.addEventListener("close", () => {
      console.log("âŒ disconnected from server");
    });

  } else {
    // â¹ï¸ ×¢×¦×™×¨×”
    await closeMicrophone(microphone);
    microphone = undefined;
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.close();
    }
    startBtn.textContent = "START"; // ×©×™× ×•×™ ×˜×§×¡×˜ ×‘×›×¤×ª×•×¨
    isRunning = false;
  }
});

async function getMicrophone() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    return new MediaRecorder(stream, { mimeType: "audio/webm" });
  } catch (error) {
    console.error("âš ï¸ error accessing microphone:", error);
    throw error;
  }
} 
  
async function openMicrophone(microphone, socket) {
  return new Promise((resolve) => {
    microphone.onstart = () => {
      console.log("ðŸŽ™ï¸ microphone opened");
      document.body.classList.add("recording");
      resolve();
    };

    microphone.onstop = () => {
      console.log("ðŸ›‘ Microphone closed");
      document.body.classList.remove("recording");
        if (socket && socket.readyState === WebSocket.OPEN) {
        socket.close();
        console.log("ðŸ”Œ WebSocket closed");
  }
    };

    microphone.ondataavailable = (event) => {
      console.log("ðŸŽ™ï¸ microphone data received");
      if (event.data.size > 0 && socket.readyState === WebSocket.OPEN) {
        socket.send(event.data);
      }
    };

 microphone.start(1000); // ×©×•×œ×— ×›×œ 1000 ms
  });
}

async function closeMicrophone(microphone) {
  console.log("ðŸ›‘ Recording stopped");
  microphone.stop();
}

</script>

</body>
</html>
